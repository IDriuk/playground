https://learnxinyminutes.com/typescript/
https://learntypescript.dev/03/l7-unknown
https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
https://www.typescriptlang.org/docs/handbook/2/functions.html
https://www.typescriptlang.org/docs/handbook/2/types-from-types.html
https://www.typescriptlang.org/play/

type State =
  | { type: "loading" }
  | { type: "success", value: number }
  | { type: "error", message: string };

type OrderSize = "regular" | "large";
type OrderItem = "Espresso" | "Cappuccino";
type Order = `A ${OrderSize} ${OrderItem}`;

type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;

enum Color { Red, Green, Blue };
let c: Color = Color.Green;
console.log(Color[c]); // "Green"

let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];
let moreNumbers: ReadonlyArray<number> = numbers;

type ID = number | string;
type Ar = (string | number)[]
type Point = {
  x: number;
  y: number;
};

interface Point {
  x: number;
  y: number;
}

interface Animal {
  name: string;
}
interface Bear extends Animal {
  honey: boolean;
}

type Animal = {
  name: string;
}
type Bear = Animal & { 
  honey: boolean;
}

interface SearchFunc {
  (source: string, subString: string): boolean;
}
function f6(i: string | number): void {
  console.log("The value was " + i);
}

interface Person {
  name: string;
  age?: number;
  move(): void;
}
function isPerson(person: any): person is Person {
  return "id" in person && "name" in person;
}
async function getPerson(id: string): Promise<Person | null> {
  const person = await getData("/people/1");
  if (person && isPerson(person)) {
    return person;
  }
  return null;
}

class Point {
  x: number;
  constructor(x: number, public y: number = 0) {
    this.x = x;
  }
  dist(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }
  static origin = new Point(0, 0);
}

class Point3D extends Point {
  constructor(x: number, y: number, public z: number = 0) {
    super(x, y); 
  }
  dist(): number {
    let d = super.dist();
    return Math.sqrt(d * d + this.z * this.z);
  }
}

class Tuple<T1, T2> {
  constructor(public item1: T1, public item2: T2) {
  }
}
interface Pair<T> {
  item1: T;
  item2: T;
}
let pairToTuple = function <T>(p: Pair<T>) {
  return new Tuple(p.item1, p.item2);
};
let tuple = pairToTuple({ item1: "hello", item2: "world" });

class Car {
  readonly make: string;
  readonly model: string;
  readonly year = 2018;
  constructor() {
    this.make = "Unknown Make"; // Assignment permitted in constructor
    this.model = "Unknown Model"; // Assignment permitted in constructor
  }
}

type A_or_B_or_C = A | B | C;

// contain all properties from all types
// The type of a common member of an intersection type is mathematically intersected.
type A_and_B_and_C = A & B & C;
type A = {
  doIt: (a: string) => void;
};
type B = {
  doIt: (a: string, b: string) => void;
};
type A_and_B = A & B;
const ab_v1: A_and_B = {
  doIt: (a: string) => {},
};

type Names = string[];
interface Names {
  [index: number]: string;
}

type Person = {
  name: string;
  score: number;
};
interface Person {
  name: string;
  score: number;
}

type Name = {
  firstName: string;
  lastName: string;
};
type PhoneNumber = {
  landline: string;
  mobile: string;
};
type Contact = Name & PhoneNumber;
interface Name {
  firstName: string;
  lastName: string;
}
interface PhoneNumber {
  landline: string;
  mobile: string;
}
interface Contact extends Name, PhoneNumber {}

type StringActions = { type: "loading" } | { type: "loaded"; data: string[] };
type NumberActions = { type: "loading" } | { type: "loaded"; data: number[] };
type Actions = StringActions & NumberActions;

function logStatus(status: string | null) {
  // We can say TypeScript has narrowed the type of status on line 3.
  if (status) {
    console.log(status);
  }
}

interface Form<T> {
  errors: {
    [K in keyof T]?: string;
  };
  values: T;
}

interface Component<T1 = string, T2 = any> { }

function getFieldValue<T, K extends keyof T>(
  ...
  fieldName: K
) { }

function logThings<T extends unknown[]>(name: string, ...things: T) { }

const button = document.querySelector(".go") as HTMLButtonElement;

return text!.concat(text!);

function sayHello(contact: Contact) {
  if (contact instanceof Person) {
    console.log("Hello " + contact.firstName);
  }
}

function isPerson(contact: Contact): contact is Person {
  return (contact as Person).firstName !== undefined;
}

let keys: keyof ExistingType;

type ContactDetails = { [K in "name" | "email"]: string };

function (param: typeof existingObject) { ... }

let billScores = Object.freeze([90, 65, 80]);

printName(obj: { first: string; last?: string })
printId(id: number | string)

function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}

const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");

const a = expr as any as T;

alignment: "left" | "right" | "center"

declare function handleRequest(url: string, method: "GET" | "POST"): void;
const req = { url: "https://example.com", method: "GET" } as const;
const req = { url: "https://example.com", method: "GET" as "GET" }

strictNullChecks
function doSomething(x: string | null) {
  if (x === null) {
  } else {
  }
}

function liveDangerously(x?: number | null) {
  console.log(x!.toFixed());
}

function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}

typeof
 type guards

"string"
"number"
"bigint"
"boolean"
"symbol"
"undefined"
"object"
"function"

if ("swim" in animal) {}

function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString());
  }
}

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}

const zoo: (Fish | Bird)[]

const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] = zoo.filter(isFish);
// or, equivalently
const underWater2: Fish[] = zoo.filter(isFish) as Fish[];
 
// The predicate may need repeating for more complex examples
const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
  if (pet.name === "sharkey") return false;
  return isFish(pet);
});

interface Circle {
  kind: "circle";
  radius: number;
}
interface Square {
  kind: "square";
  sideLength: number;
}
type Shape = Circle | Square;
if (shape.kind === "circle") { return Math.PI * shape.radius ** 2; }

const _exhaustiveCheck: never = shape;

type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

type SomeConstructor = {
  new (s: string): SomeObject;
};

interface CallOrConstruct {
  (n?: number): string;
  new (s: string): Date;
}

function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}

function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}
const db = getDB();
const admins = db.filterUsers(function (this: User) {
  return this.admin;
});


function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
arr1.push(...arr2);

function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}

function f2(): void {
  // @ts-expect-error
  return true;
}

interface PaintOptions {
  shape: Shape;
  xPos?: number;
  yPos?: number;
}

interface Home {
  readonly resident: { name: string; age: number };
}

interface StringArray {
  [index: number]: string;
}

interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: unknown;
}

interface Colorful {
  color: string;
}
interface Circle {
  radius: number;
}
interface ColorfulCircle extends Colorful, Circle {}

type OrNull<Type> = Type | null;
type OneOrMany<Type> = Type | Type[];
type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;   
type OneOrManyOrNull<Type> = OneOrMany<Type> | null
type OneOrManyOrNullStrings = OneOrManyOrNull<string>;

function doSomething(stringHash: [string, number]) {
  const [inputString, hash] = stringHash;}

type Either2dOr3d = [number, number, number?];
type StringNumberBooleans = [string, number, ...boolean[]];

function identity<Type>(arg: Type): Type {
  return arg;
}
let myIdentity: <Input>(arg: Input) => Input = identity;

function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key];
}
let x = { a: 1, b: 2, c: 3, d: 4 };
getProperty(x, "a");

function createInstance<A extends Animal>(c: new () => A): A {
  return new c();
}

type Predicate = (x: unknown) => boolean;
type K = ReturnType<Predicate>;

function f() {
  return { x: 10, y: 3 };
}
type P = ReturnType<typeof f>;

type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
type I1 = Person["age" | "name"];
type I1 = string | number
type I2 = Person[keyof Person];
type I2 = string | number | boolean
type AliveOrName = "alive" | "name";
type I3 = Person[AliveOrName];

type OptionsFlags<Type> = {
  [Property in keyof Type]: boolean;
};
type Features = {
  darkMode: () => void;
  newUserProfile: () => void;
};
type FeatureOptions = OptionsFlags<Features>;

type CreateMutable<Type> = {
  -readonly [Property in keyof Type]: Type[Property];
};
type LockedAccount = {
  readonly id: string;
  readonly name: string;
};
type UnlockedAccount = CreateMutable<LockedAccount>;

type Concrete<Type> = {
  [Property in keyof Type]-?: Type[Property];
};
type MaybeUser = {
  id: string;
  name?: string;
  age?: number;
};
type User = Concrete<MaybeUser>;

"use strict";
class C {
    constructor() {
        this._length = 0;
    }
    get length() {
        return this._length;
    }
    set length(value) {
        this._length = value;
    }
}

interface Pingable {
  ping(): void;
}
class Sonar implements Pingable {
  ping() {
    console.log("ping!");
  }
}

class Base {
  greet() {
    console.log("Hello, world!");
  }
}
class Derived extends Base {
  greet(name?: string) {
    if (name === undefined) {
      super.greet();
    } else {
      console.log(`Hello, ${name.toUpperCase()}`);
    }
  }
}

class Foo {
    static #count = 0;
    get count() {
        return Foo.#count;
    }
}

function fn(this: SomeType, x: number) { }

isFile(): this is FileRep {
  return this instanceof FileRep;
}

class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}

.d.ts
declare class C {
    _length: number;
    get length(): number;
    set length(value: number);
}

/// <reference path="jquery.d.ts" />
declare const backpack: Backpack<string>;

// In a .d.ts file or .ts file that is not a module:
declare module "SomeModule" {
  export function fn(): string;
}

/// <reference path="myModules.d.ts" />
import * as m from "SomeModule";

module Geometry {
  export class Square {
    constructor(public sideLength: number = 0) {
    }
    area() {
      return Math.pow(this.sideLength, 2);
    }
  }
}
let s1 = new Geometry.Square(5);
import G = Geometry;
let s2 = new G.Square(10);

It is legal in TypeScript for multiple interfaces with the same name to be created. 
TypeScript will merge interfaces with the same name in a process called declaration merging.